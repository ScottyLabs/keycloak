name: CD

on:
  push:
    branches:
      - main
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      deploy_environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  REGISTRY: ghcr.io

jobs:
  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.push.outputs.digest }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set image name to lowercase
        run: echo "IMAGE_NAME=${REPO,,}" >> $GITHUB_ENV
        env:
          REPO: ${{ github.repository }}

      - name: Install Podman
        run: |
          sudo apt-get update
          sudo apt-get install -y podman

      - name: Log in to Container Registry
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | podman login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Extract metadata for container image
        id: meta
        run: |
          # Generate tags based on event type
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            TAGS="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION},${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          elif [[ "${{ github.ref }}" == refs/heads/main ]]; then
            TAGS="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          else
            TAGS="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          fi
          echo "tags=${TAGS}" >> $GITHUB_OUTPUT
          echo "Generated tags: ${TAGS}"

      - name: Build container image
        run: |
          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.meta.outputs.tags }}"
          TAG_ARGS=""
          for tag in "${TAG_ARRAY[@]}"; do
            TAG_ARGS="$TAG_ARGS -t $tag"
          done
          podman build $TAG_ARGS .

      - name: Push container image
        id: push
        run: |
          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.meta.outputs.tags }}"
          for tag in "${TAG_ARRAY[@]}"; do
            echo "Pushing $tag"
            podman push $tag
          done
          # Get digest from the first tag
          DIGEST=$(podman inspect ${TAG_ARRAY[0]} --format '{{.Digest}}')
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || github.event.inputs.deploy_environment == 'staging'
    environment:
      name: staging
      url: https://staging-idp.scottylabs.org
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy to staging server
        env:
          DEPLOY_HOST: ${{ secrets.STAGING_HOST }}
          DEPLOY_USER: ${{ secrets.STAGING_USER }}
          DEPLOY_KEY: ${{ secrets.STAGING_SSH_KEY }}
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts 2>/dev/null

          # Get the first tag (primary tag)
          PRIMARY_TAG=$(echo "$IMAGE_TAG" | cut -d',' -f1)

          # Deploy using SSH
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST << EOF
            cd /opt/keycloak
            
            # Pull the new image
            podman pull $PRIMARY_TAG
            
            # Update the compose file to use the new image (or use environment variable)
            export KEYCLOAK_IMAGE=$PRIMARY_TAG
            
            # Restart services with new image
            podman-compose down
            podman-compose up -d
            
            # Health check
            sleep 30
            curl -f http://localhost:8080/health/ready || exit 1
            
            echo "Deployment to staging completed successfully!"
          EOF

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-staging]
    if: startsWith(github.ref, 'refs/tags/v') || github.event.inputs.deploy_environment == 'production'
    environment:
      name: production
      url: https://idp.scottylabs.org
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy to production server
        env:
          DEPLOY_HOST: ${{ secrets.PRODUCTION_HOST }}
          DEPLOY_USER: ${{ secrets.PRODUCTION_USER }}
          DEPLOY_KEY: ${{ secrets.PRODUCTION_SSH_KEY }}
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image-tag }}
        run: |
          # Setup SSH
          mkdir -p ~/.ssh
          echo "$DEPLOY_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H $DEPLOY_HOST >> ~/.ssh/known_hosts 2>/dev/null

          # Get the first tag (primary tag)
          PRIMARY_TAG=$(echo "$IMAGE_TAG" | cut -d',' -f1)

          # Deploy using SSH
          ssh -i ~/.ssh/deploy_key $DEPLOY_USER@$DEPLOY_HOST << EOF
            cd /opt/keycloak
            
            # Pull the new image
            podman pull $PRIMARY_TAG
            
            # Create backup of current state
            podman-compose exec postgres pg_dump -U keycloak keycloak > /opt/keycloak/backups/backup-\$(date +%Y%m%d-%H%M%S).sql || true
            
            # Update the compose file to use the new image
            export KEYCLOAK_IMAGE=$PRIMARY_TAG
            
            # Restart services with new image
            podman-compose down
            podman-compose up -d
            
            # Health check with retries
            for i in {1..6}; do
              sleep 10
              if curl -f http://localhost:8080/health/ready; then
                echo "Production deployment completed successfully!"
                exit 0
              fi
              echo "Health check attempt \$i failed, retrying..."
            done
            
            echo "Health check failed after all retries"
            exit 1
          EOF

  notify:
    name: Notify on Deployment
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result != 'skipped' || needs.deploy-production.result != 'skipped')
    steps:
      - name: Send notification
        run: |
          if [[ "${{ needs.deploy-production.result }}" == "success" ]]; then
            echo "✅ Production deployment successful!"
          elif [[ "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "✅ Staging deployment successful!"
          else
            echo "❌ Deployment failed!"
          fi
          # Add your notification logic here (Slack, Discord, email, etc.)
          # Example: curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"Deployment completed"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
